using ShieldSec.Core.Managers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ShieldSec.Core.Requests
{
    /// <summary>
    ///  This class is responsible for fetching malware hashes from the web and updating the local storage file.
    /// </summary>
    public class MalwareHashRequest : IDisposable
    {
        private const string FeedUrl = "https://bazaar.abuse.ch/export/txt/sha256/recent/";
        private readonly HttpClient _httpClient;
        private readonly string _storageFilePath;
        /// <summary>
        ///  Constructor for the MalwareHashRequest, which initializes the HttpClient and the storage file path.
        /// </summary>
        /// <param name="storageFilePath"></param>
        public MalwareHashRequest(string storageFilePath)
        {
            _storageFilePath = storageFilePath;
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Add("User-Agent", "MalwareHashRequest/1.0");
        }
        /// <summary>
        ///  Fetches and updates the hashes from the web.
        /// </summary>
        /// <returns> The number of new hashes fetched </returns>
        public async Task<int> FetchAndUpdateHashesAsync()
        {
            var fetchedHashes = await FetchHashesFromWebAsync();
            var existingHashes = LoadExistingHashes();
            var newHashes = GetNewHashes(fetchedHashes, existingHashes).ToList();
            if (newHashes.Count > 0)
            {
                await AppendNewHashesAsync(newHashes);
            }

            NotificationManager.ShowToast("New Hashes", $"Found {newHashes.Count} new malware hash(es)", "", Enums.NotificationType.GENERIC);
            return newHashes.Count;
        }
        /// <summary>
        ///  Fetches the hashes from the web asynchronously.
        /// </summary>
        /// <returns> The fetched hashes </returns>
        private async Task<IEnumerable<string>> FetchHashesFromWebAsync()
        {
            var response = await _httpClient.GetStringAsync(FeedUrl);
            return ParseHashesFromResponse(response);
        }
        /// <summary>
        ///  Parses the hashes from the response.
        /// </summary>
        /// <param name="response"> The response to parse </param>
        /// <returns> The parsed hashes </returns>
        private IEnumerable<string> ParseHashesFromResponse(string response)
        {
            foreach (var line in response.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries))
            {
                if (line.StartsWith('#') || string.IsNullOrWhiteSpace(line))
                    continue;

                var hash = line.Trim().ToLowerInvariant();
                if (IsValidSha256Hash(hash))
                {
                    yield return hash;
                }
            }
        }
        /// <summary>
        ///  Loads exising hashes from the storage file.
        /// </summary>
        /// <returns> The existing hashes </returns>
        private HashSet<string> LoadExistingHashes()
        {
            if (!File.Exists(_storageFilePath))
            {
                return new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            }

            return new HashSet<string>(
                File.ReadLines(_storageFilePath)
                    .Select(line => line.Trim().ToLowerInvariant())
                    .Where(IsValidSha256Hash),
                StringComparer.OrdinalIgnoreCase
            );
        }
        /// <summary>
        ///  Gets the new hashes from the fetched hashes and excludes the existing hashes from the new hashes.
        /// </summary>
        /// <param name="fetchedHashes"> The fetched hashes </param>
        /// <param name="existingHashes"> The existing hashes </param>
        /// <returns></returns>
        private static IEnumerable<string> GetNewHashes(IEnumerable<string> fetchedHashes, HashSet<string> existingHashes)
        {
            return fetchedHashes
                .Where(hash => !existingHashes.Contains(hash))
                .OrderBy(hash => hash);
        }
        /// <summary>
        ///  Appends the new hashes to the storage file.
        /// </summary>
        /// <param name="newHashes"> The new hashes to append </param>
        /// <returns> Task </returns>
        private async Task AppendNewHashesAsync(IEnumerable<string> newHashes)
        {
            await File.AppendAllLinesAsync(_storageFilePath, newHashes);
        }
        /// <summary>
        ///  Checks if the hash is a valid SHA-256 hash.
        /// </summary>
        /// <param name="hash"> The hash to check </param>
        /// <returns> True if the hash is a valid SHA-256 hash, false otherwise </returns>
        private static bool IsValidSha256Hash(string hash)
        {
            return hash.Length == 64 && hash.All(c => IsHexDigit(c));
        }
        /// <summary>
        ///  Checks if the character is a hexadecimal digit.
        /// </summary>
        /// <param name="c"> The character to check </param>
        /// <returns> True if the character is a hexadecimal digit, false otherwise </returns>
        private static bool IsHexDigit(char c)
        {
            return c is (>= '0' and <= '9') or (>= 'a' and <= 'f') or (>= 'A' and <= 'F');
        }
        /// <summary>
        ///  Diposes the HttpClient and suppresses the finalizer (GC).
        /// </summary>
        public void Dispose()
        {
            _httpClient.Dispose();
            GC.SuppressFinalize(this);
        }
    }
}
